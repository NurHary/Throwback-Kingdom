use crate::{gamestate::startup, tkglobal_var, tkquadtree};
use bevy::prelude::*;
// Plugins//
//
//Ini adalah Plugin yang mana Plugin ini akan berjalan ketika

#[derive(Copy, Clone)]
pub enum CollisionType {
    UNIT,
    ITEMS,
}

pub struct TkPhysicsPlugin;

impl Plugin for TkPhysicsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            Update,
            (access_quadtree_physics).run_if(in_state(tkglobal_var::GameState::Play)),
        );
    }
}

/// Struct untuk bentuk segi empat
/// model dari struct ini dalam model ECS sehingga ia hanya menyimpan informasi terkait width dan
/// height saja. untuk posisinya diambil dari entity yang memegangnya (dimana pasti memiliki
/// transform)
#[derive(Component, Clone, Copy)]
pub struct TkRectangle {
    pub width: f32,
    pub height: f32,
}

// ini tidak akan mungkin mengingat posisi dari TkRectangle terletak pada entity Transform itu
// sendiri. jadi kita disini akan mengabaikan fungsi bawaannya
impl TkRectangle {
    pub fn new(width: f32, height: f32) -> Self {
        Self { width, height }
    }
    pub fn unwrap_position3(&self, tr: Vec3) -> [Vec3; 4] {
        let x0 = tr.x - self.width / 2.;
        let y0 = tr.y - self.height / 2.;
        let x1 = tr.x + self.width / 2.;
        let y1 = tr.y + self.height / 2.;
        let x0y0 = Vec3::new(x0, y0, tr.z);
        let x1y0 = Vec3::new(x1, y0, tr.z);
        let x0y1 = Vec3::new(x0, y1, tr.z);
        let x1y1 = Vec3::new(x1, y1, tr.z);
        [x0y0, x1y0, x0y1, x1y1]
    }
    // Fungsi yang digunakan untuk mendapatkan nilai dari cordinat x0, y0, x1, y1 dari tk rectangle
    // itu sendiri
    //
    // pada dasarnya tk rectangle menggunakaan unit Transform itu sendiri untuk
    pub fn unwrap_coord(&self, tr: &Vec3) -> [f32; 4] {
        let x0 = tr.x - self.width / 2.;
        let y0 = tr.y - self.height / 2.;
        let x1 = tr.x + self.width / 2.;
        let y1 = tr.y + self.height / 2.;
        [x0, y0, x1, y1]
    }
}

/// Struct untuk bentuk Capsules (tidur)
/// model dari struct ini dalam model ECS sehingga han ya menyimpan radius dari lingkaran tersebut
/// tanpa menyertakan posisinya. untuk posisinya diambil dari entity yang memegangnya (dimana pasti
/// memiliki transform)
#[derive(Component, Clone, Copy)]
struct TkCapsules {
    width: f32, // width ada, tapi height = rad
    rad: f32,
}

impl TkCapsules {
    /// fungsi init untuk membuat componen ECS TkCircles
    pub fn new(width: f32, rad: f32) -> Self {
        Self { width, rad }
    }
}

#[derive(Component)]
pub struct EntityColliding {
    colliding: bool,
    col_type: CollisionType,
}

impl EntityColliding {
    pub fn new(coltype: CollisionType) -> Self {
        Self {
            colliding: false,
            col_type: coltype,
        }
    }
}

pub fn get_quadtree_information() {}

/// Fungsi untuk mengakses Quadtree serta melakukan pengecekan collision berdasarkan isi dari
/// Quadtree tersebut
pub fn access_quadtree_physics(
    qr: Query<
        (&mut EntityColliding, &TkRectangle, &Transform, Entity),
        With<tkquadtree::QuadtreeUnit>,
    >,
    qt: Res<tkquadtree::TkQuadTree>,
) {
    println!("List: {:?}", qt.get_all_entity());
    // mendapatkan semua entity dalam quadtree
    if let Some(all_en) = qt.get_all_entity() {
        // iterasikan vector tersebut untuk mengakses vector di dalamnya
        for part_all_en in all_en {
            // apabila len 1, make skip
            if part_all_en.len() == 1 {
                break;
            }
            // TODO: lakukan fungsi untuk mengecek collision antara 2 unit tersebut
            check_collision(&qr, part_all_en);
        }
    }
}

pub fn check_collision(
    mut aabb_query: &Query<
        (&mut EntityColliding, &TkRectangle, &Transform, Entity),
        With<tkquadtree::QuadtreeUnit>,
    >,
    qt_data: &Vec<Entity>,
) { //

    //for (mut entycoll, rectang, tr, entity) in &aabb_query {
    //    let this_min_x = tr.translation.x - rectang.width / 2.0;
    //    let this_max_x = tr.translation.x + rectang.width / 2.0;
    //    let this_min_y = tr.translation.y - rectang.height / 2.0;
    //    let this_max_y = tr.translation.y + rectang.height / 2.0;
    //    for (mut other_entycoll, other_rectang, other_tr, other_entiti) in &aabb_query {
    //        let other_min_x = other_tr.translation.x - other_rectang.width / 2.0;
    //        let other_max_x = other_tr.translation.x + other_rectang.width / 2.0;
    //        let other_min_y = other_tr.translation.y - other_rectang.height / 2.0;
    //        let other_max_y = other_tr.translation.y + other_rectang.height / 2.0;
    //        if entity != other_entiti {
    //            if this_min_x <= other_max_x
    //                && this_max_x >= other_min_x
    //                && this_min_y <= other_max_y
    //                && this_max_y >= other_min_y
    //            {
    //                println!("Other min x: {}, This max x: {}", other_min_x, this_max_x);
    //                println!("Other min y: {}, This max y: {}", other_min_y, this_max_y);
    //                println!("Other max x: {}, This min x: {}", other_max_x, this_min_x);
    //                println!("Other max y: {}, This min y: {}", other_max_y, this_min_y);
    //                println!("Ditabrak dengan {}", other_entiti);
    //                println!("Terdapat Tabrakan")
    //            }
    //        }
    //    }
    //}
}
